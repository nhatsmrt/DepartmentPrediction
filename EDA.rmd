---
title: "Exploring Data"
author: "Nhat Pham"
output:
  html_notebook: default
  html_document: default
---
```{r include = FALSE}
## https://www.r-graph-gallery.com/248-igraph-plotting-parameters/
library(igraph)
library(dplyr)
```


```{r}
df_edges_list <- read.csv("./Data/edges_list.csv")
df_labels <- read.csv("./Data/department_labels.csv")
graph <- graph_from_data_frame(df_edges_list, directed = TRUE)
graph <- graph %>%  set_vertex_attr("department", value = df_labels %>% select("department_id") %>% pull())

graph_simplified <- graph %>% simplify()
```

```{r}
isolated <- which(degree(graph_simplified) == 0)
graph_simplified <- delete.vertices(graph_simplified, isolated)
```

## Visualization
As the graph is too big, we will be content with visualizing a random subgraph of it:

```{r}
sampled_nodes <- sample(V(graph_simplified), 100, replace=F)
subgraph <- induced_subgraph(graph_simplified, sampled_nodes)
```


```{r fig.width=2, fig.height=2}
plot(
  subgraph,
  vertex.label = NA,
  layout = layout.auto(subgraph),
  vertex.size = 3, edge.arrow.size = 0.01,
  vertex.color = vertex_attr(subgraph, 'department')
)
```


## Graph Statistics
Now let us look at some statistics of the graphs:
<br>
1. *Diameter of the graph*: `r diameter(graph)`
<br>
2. *Maximum degree*: `r max(degree(graph, mode = "all"))`. Maximum out-degree: `r max(degree(graph, mode = "out"))`. Maximum in-degree: `r max(degree(graph, mode = "in"))`
<br>
3. *Average path length of the graph*: `r mean_distance(graph, directed = TRUE)`
<br>
4. *Density of graph*: `r edge_density(graph)`
<br>
5. *Global transitivity of the graph*: `r transitivity(graph)`
<br>
6. *Reciprocity* (percentage of edges that are symmetrical): `r reciprocity(graph)`
<br>
The high reciprocity suggests that most correspondents are two ways: if a research sends an email to another, it is very likely that he/she will receive a reply.
<br>
Now, let us compare this statistics with that of random graphs with similar number of edges (and density). For instance, let us generate a thousand of such graphs and draw the histogram of their average path lengths:
```{r}
gl <- vector('list', 1000)
for (i in 1:1000) {
  gl[[i]] <- erdos.renyi.game(n = gorder(graph), p.or.m = edge_density(graph), type = "gnp")
}

gl_apls <- unlist(lapply(gl, mean_distance, directed = TRUE))

hist(
  gl_apls,
  xlim = range(c(2.45, 2.70)),
  main = "Histogram of Average Path Lengths",
  xlab = "Average Path Lengths",
  col = "blue"
)
abline(v = mean_distance(graph, directed = TRUE), col = "red", lty = 3, lwd = 2)
```

As we can see, the average path length of the graph is relatively higher than graphs with similar number of edges and density.
We can also compute some statistics of the nodes:

```{r}
between_centrality <- betweenness(graph, V(graph), normalized = TRUE)
```
## Community Detection (Unsupervised)

Here, we will apply some built-in unsupervised community detection methods provided by the igraph package.
### Fast-Greedy
The first one we will examine is the fast-greedy method:
```{r}
community_fg <- fastgreedy.community(as.undirected(graph))
```
Some statistics of the result:
<br>
1. Number of communities: `r length(community_fg)`
<br>
2. Sizes of the communities: `r sizes(community_fg)`
<br>
If we look at the breakdown of the values:
```{r}
table(sizes(community_fg))
```
We can see that the majority of the communities only have 1 members (i.e isolated). Some larger communities have up too more than 300 members!
<br>
The membership of each vertex can be found via:
```{r}
membership_fg <- membership(community_fg)
```

### Edge-Betweenness:
Now let us apply the edge-betweenness method:
```{r}
community_le <- leading.eigenvector.community(as.undirected(graph))
```
Some statistics of the result:
<br>
1. Number of communities: `r length(community_le)`
<br>
2. Sizes of the communities: `r sizes(community_le)`
<br>
Again, looking at the breakdown of the values:
```{r}
table(sizes(community_le))
```
We see that the number of isolated communities have decreased, and the larger communities are also less extreme.
<br>
This seems like a more plausible representation of the true community structure.
<br>
The membership of each vertex can be found via:
```{r}
membership_le <- membership(community_le)
```


